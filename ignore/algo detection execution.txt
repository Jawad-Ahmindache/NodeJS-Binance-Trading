Je put les paires si elle existe pas dans un tableau de l'objet API
Les paires contiendra l'id des chemins qui l'utilisent



Je crée un stream websocket dans l'api
DETECTION : 
-------------------------

> On recoit les infos de l'order 
> On prend la paire reçu et les infos de la paire 
> On  parcours tous les chemins de la paire
> On crée une variable bool isRecent //si true on peut comparer les prix, si false on peut pas
> On prcours chaque étapes du chemin
			       > Si c'est la bonne paire on met le last à Date.now() et on met tmp
			       > Si c'est pas la bonne paire on compare last et date.now() et si ça fait <= 300ms true sinon false
> On appelle une fonction calculChemin(chemin), on lui envoie le chemin et il le calcul. Si le gain est positive, on affiche dans la console  la date, nos crypto(sell/buy), le la mise de départ, la mise finale et le pourcentage d'écart entre les deux.

affichage : [DETECTION][2023-01-01] BTC(buy)-ETH(buy)-USDT(sell) :
							miseDepart: 1000
							miseFinale: 1010
							gain: 10
							gainPourcent: 1%
							
~ Dans un premier temps pour voir quel minimum de gain on lance juste la detection pour voir quel minimum de gain on peut avoir puis on le fixe dans une constante
D'ailleurs je vais faire deux fonction de detection une withExecution qui affiche que les executions et une withoutExecution qui ne fait pas d'execution mais qui affiche les detections ça permet de check de temps en temps le minimum

EXECUTION :
-----------------------
- Si le gainPourcent > 1% on lance la fonction execution() avec la bonne mise de départ et on met en pause la connexion websocket qui fait la detection. 
- On prend la mise dispo dans api.mise et on la fixe en mise de départ
- On parcours les etapes
- On prend les infos de l'order book et en fonction du side on prend le price
- On calcule la quantité incluant les fees et le stepsize
- On lance l'order E1
	> Si pas Ok on lance execution error
	> Si OK on continue
		> On check order status Si waiting = On attend, Si error = execuction error 
		> Si si OK = On passe à E2 (et la mise de E2 sera executedQTY)

- On lance l'order E2
	> Si pas Ok on lance execution error
		> On renvoie la somme en cryptoDepart
	> Si OK on continue
		> On check order status Si waiting = On attend, Si error = execuction error 
		> Si si OK = On passe à E3 (et la mise de E3 sera executedQTY)
- On lance l'order E3
	> Si pas Ok on lance execution error
		> On renvoie la somme en USDT
	> Si OK on continue
		> On check order status Si waiting = On attend, Si error = execuction error 
		> Si si OK = on finalise
Finalisation : 
	- 
	